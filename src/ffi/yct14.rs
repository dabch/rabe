use schemes::yct14::*;
use serde::{Serialize};
use serde_cbor::{self, Serializer, ser::SliceWrite};
use core::slice;
use heapless::{Vec, consts};

use core::panic::PanicInfo;
use nrf52832_hal as hal;

/// @file
/// @author Daniel Buecheler <daniel.buecheler@tum.de>
/// @version 0.0.1
/// @section DESCRIPTION
/// C language bindings to the YCT14 ABE scheme of the rabe library. 
/// Papercuts and stuff you should know:
/// - only encryption is implemented. 
/// - public parameters, including the number and names of attributes are compiled into the binary (at this point). See below.
/// - the number of attributes in the universe, attributes per plaintext etc is limited to 8. This is because we are using the Gt elements of `rabe_bn` (the underlying pairing library) and those are huge (over 350 bytes each)
/// - generally, the parameters are big in size: almost 4000 bytes for the Yct14AbeKeyEncapsulation with a limit of 8 attributes
/// - ciphertexts are immediately serialized into CBOR. The ciphertext BLOBs output by this library are identical to the ciphertexts generated by the "full" rabe library (the internal layout is different, which is why ciphertexts are immediately serialized).


const G_SER: &[u8] = &[162, 98, 99, 48, 163, 98, 99, 48, 162, 98, 99, 48, 132, 27, 150, 119, 3, 121, 192, 142, 173, 184, 27, 23, 224, 23, 114, 59, 201, 22, 54, 27, 167, 225, 229, 224, 237, 68, 137, 157, 27, 3, 96, 207, 167, 22, 230, 131, 98, 98, 99, 49, 132, 27, 18, 28, 61, 109, 253, 237, 33, 161, 27, 118, 180, 206, 179, 89, 214, 198, 79, 27, 238, 40, 250, 80, 40, 62, 8, 155, 27, 12, 193, 2, 144, 150, 97, 174, 138, 98, 99, 49, 162, 98, 99, 48, 132, 27, 225, 241, 241, 91, 126, 24, 20, 164, 27, 68, 175, 103, 69, 28, 244, 47, 185, 27, 242, 55, 178, 99, 111, 155, 101, 26, 27, 46, 191, 88, 102, 32, 233, 124, 59, 98, 99, 49, 132, 27, 101, 155, 54, 55, 61, 6, 102, 236, 27, 203, 31, 68, 49, 160, 171, 29, 153, 27, 9, 4, 219, 6, 52, 70, 158, 103, 27, 12, 135, 160, 185, 220, 53, 49, 149, 98, 99, 50, 162, 98, 99, 48, 132, 27, 86, 85, 115, 222, 212, 191, 183, 223, 27, 94, 217, 157, 187, 160, 25, 188, 43, 27, 232, 229, 234, 138, 255, 125, 40, 109, 27, 17, 228, 246, 91, 211, 228, 201, 106, 98, 99, 49, 132, 27, 212, 18, 195, 81, 136, 160, 4, 248, 27, 98, 36, 19, 47, 216, 43, 214, 229, 27, 231, 155, 14, 98, 173, 214, 34, 214, 27, 36, 68, 219, 2, 113, 21, 77, 28, 98, 99, 49, 163, 98, 99, 48, 162, 98, 99, 48, 132, 27, 223, 117, 23, 10, 146, 186, 62, 24, 27, 185, 238, 26, 107, 62, 180, 49, 210, 27, 47, 107, 224, 239, 18, 184, 79, 163, 27, 19, 231, 130, 195, 168, 109, 57, 38, 98, 99, 49, 132, 27, 218, 123, 114, 80, 76, 254, 197, 241, 27, 183, 207, 8, 86, 24, 162, 29, 62, 27, 172, 51, 176, 60, 177, 76, 107, 175, 27, 11, 76, 233, 187, 240, 75, 79, 79, 98, 99, 49, 162, 98, 99, 48, 132, 27, 243, 51, 239, 147, 216, 188, 160, 97, 27, 251, 143, 26, 187, 132, 32, 170, 234, 27, 130, 126, 177, 112, 90, 128, 183, 250, 27, 15, 253, 72, 22, 200, 55, 68, 176, 98, 99, 49, 132, 27, 189, 251, 228, 190, 19, 7, 221, 16, 27, 83, 15, 142, 158, 150, 92, 220, 115, 27, 161, 20, 221, 125, 142, 217, 59, 41, 27, 33, 238, 162, 93, 194, 181, 33, 55, 98, 99, 50, 162, 98, 99, 48, 132, 27, 159, 199, 62, 74, 40, 125, 34, 68, 27, 110, 125, 80, 204, 131, 37, 171, 147, 27, 65, 202, 176, 108, 8, 50, 220, 52, 27, 35, 81, 88, 145, 65, 248, 36, 143, 98, 99, 49, 132, 27, 44, 69, 97, 191, 83, 27, 61, 115, 27, 156, 205, 36, 72, 190, 101, 147, 107, 27, 70, 178, 235, 200, 216, 237, 248, 100, 27, 16, 41, 38, 160, 150, 175, 110, 191];
const A_SER: &[u8] = &[162, 100, 110, 97, 109, 101, 97, 65, 100, 110, 111, 100, 101, 161, 102, 80, 117, 98, 108, 105, 99, 162, 98, 99, 48, 163, 98, 99, 48, 162, 98, 99, 48, 132, 27, 225, 172, 205, 193, 109, 212, 29, 195, 27, 237, 203, 1, 20, 95, 142, 233, 232, 27, 90, 44, 134, 186, 150, 8, 52, 215, 27, 28, 111, 51, 192, 162, 43, 78, 123, 98, 99, 49, 132, 27, 229, 98, 72, 27, 196, 221, 102, 187, 27, 158, 227, 2, 76, 108, 236, 45, 138, 27, 54, 41, 18, 17, 102, 215, 196, 95, 27, 31, 85, 127, 239, 78, 117, 84, 191, 98, 99, 49, 162, 98, 99, 48, 132, 27, 243, 35, 228, 75, 211, 55, 181, 43, 27, 199, 182, 207, 231, 253, 194, 29, 14, 27, 229, 139, 150, 15, 121, 93, 33, 193, 27, 30, 90, 207, 45, 234, 28, 41, 184, 98, 99, 49, 132, 27, 146, 93, 191, 120, 32, 26, 158, 217, 27, 228, 165, 18, 240, 176, 78, 81, 78, 27, 54, 232, 122, 16, 225, 112, 226, 16, 27, 45, 219, 109, 127, 70, 169, 63, 108, 98, 99, 50, 162, 98, 99, 48, 132, 27, 182, 185, 27, 73, 45, 200, 131, 13, 27, 27, 152, 83, 108, 124, 177, 155, 159, 27, 160, 49, 36, 204, 69, 74, 91, 159, 27, 36, 40, 213, 35, 216, 95, 65, 92, 98, 99, 49, 132, 27, 5, 139, 12, 126, 170, 81, 177, 200, 27, 45, 205, 176, 188, 169, 89, 180, 126, 27, 125, 73, 248, 195, 226, 101, 72, 24, 27, 1, 244, 177, 119, 43, 147, 108, 24, 98, 99, 49, 163, 98, 99, 48, 162, 98, 99, 48, 132, 27, 81, 188, 173, 57, 141, 127, 1, 177, 27, 251, 148, 49, 213, 26, 210, 112, 16, 27, 173, 154, 238, 79, 187, 247, 140, 205, 27, 22, 139, 35, 206, 56, 130, 54, 109, 98, 99, 49, 132, 27, 200, 112, 112, 160, 86, 113, 207, 65, 27, 134, 25, 132, 140, 172, 89, 64, 79, 27, 144, 123, 132, 93, 14, 240, 113, 114, 27, 41, 5, 223, 106, 144, 90, 102, 194, 98, 99, 49, 162, 98, 99, 48, 132, 27, 146, 188, 22, 187, 198, 205, 123, 117, 27, 117, 61, 9, 130, 80, 137, 2, 152, 27, 61, 177, 119, 225, 225, 45, 29, 141, 27, 15, 246, 198, 231, 145, 7, 182, 125, 98, 99, 49, 132, 27, 224, 102, 55, 255, 81, 14, 142, 171, 27, 81, 185, 146, 48, 44, 192, 56, 113, 27, 133, 180, 10, 136, 214, 202, 193, 181, 27, 21, 97, 201, 231, 214, 46, 36, 214, 98, 99, 50, 162, 98, 99, 48, 132, 27, 154, 190, 215, 22, 30, 127, 39, 149, 27, 139, 180, 219, 83, 250, 172, 74, 11, 27, 146, 2, 183, 97, 94, 12, 42, 12, 27, 23, 33, 64, 20, 40, 237, 178, 223, 98, 99, 49, 132, 27, 188, 49, 169, 28, 252, 115, 211, 133, 27, 20, 73, 66, 17, 59, 101, 93, 159, 27, 17, 144, 200, 26, 31, 251, 107, 50, 27, 11, 235, 212, 181, 107, 63, 132, 198];
const B_SER: &[u8] = &[162, 100, 110, 97, 109, 101, 97, 66, 100, 110, 111, 100, 101, 161, 102, 80, 117, 98, 108, 105, 99, 162, 98, 99, 48, 163, 98, 99, 48, 162, 98, 99, 48, 132, 27, 160, 78, 126, 187, 96, 232, 92, 14, 27, 198, 242, 83, 64, 145, 75, 113, 88, 27, 176, 166, 242, 42, 63, 31, 76, 130, 27, 18, 223, 124, 1, 250, 237, 162, 117, 98, 99, 49, 132, 27, 181, 64, 0, 170, 142, 87, 252, 137, 27, 10, 115, 22, 129, 160, 225, 130, 176, 27, 153, 17, 193, 249, 35, 173, 13, 144, 27, 22, 255, 189, 81, 231, 186, 78, 240, 98, 99, 49, 162, 98, 99, 48, 132, 27, 115, 234, 84, 93, 18, 204, 157, 46, 27, 177, 216, 242, 55, 101, 216, 223, 130, 27, 244, 49, 220, 158, 186, 211, 147, 128, 27, 28, 156, 110, 93, 201, 88, 191, 238, 98, 99, 49, 132, 27, 147, 62, 77, 92, 233, 10, 58, 245, 27, 125, 233, 163, 32, 89, 220, 235, 36, 27, 4, 176, 200, 9, 171, 254, 197, 218, 27, 4, 60, 26, 82, 121, 93, 228, 54, 98, 99, 50, 162, 98, 99, 48, 132, 27, 112, 237, 22, 47, 163, 249, 28, 191, 27, 75, 91, 151, 113, 38, 8, 75, 87, 27, 117, 127, 35, 199, 10, 100, 124, 41, 27, 38, 212, 237, 40, 10, 224, 247, 232, 98, 99, 49, 132, 27, 81, 45, 139, 199, 53, 97, 46, 176, 27, 162, 76, 144, 51, 218, 154, 216, 192, 27, 112, 166, 216, 224, 56, 243, 54, 93, 27, 28, 77, 237, 104, 138, 117, 128, 155, 98, 99, 49, 163, 98, 99, 48, 162, 98, 99, 48, 132, 27, 77, 109, 215, 158, 101, 115, 98, 51, 27, 223, 249, 23, 62, 122, 204, 67, 204, 27, 160, 230, 133, 239, 120, 108, 240, 198, 27, 25, 249, 36, 26, 60, 54, 128, 174, 98, 99, 49, 132, 27, 244, 34, 52, 84, 251, 169, 199, 156, 27, 105, 147, 24, 235, 139, 171, 128, 170, 27, 93, 205, 67, 236, 188, 49, 228, 92, 27, 28, 165, 114, 169, 149, 91, 77, 39, 98, 99, 49, 162, 98, 99, 48, 132, 27, 55, 194, 68, 136, 38, 116, 22, 13, 27, 209, 196, 91, 146, 100, 202, 241, 213, 27, 205, 110, 34, 33, 5, 213, 153, 224, 27, 17, 126, 146, 20, 66, 58, 78, 62, 98, 99, 49, 132, 27, 88, 35, 125, 10, 45, 116, 174, 10, 27, 49, 35, 69, 190, 165, 134, 209, 189, 27, 188, 192, 24, 74, 44, 145, 233, 180, 27, 29, 140, 237, 24, 225, 42, 121, 122, 98, 99, 50, 162, 98, 99, 48, 132, 27, 226, 233, 40, 242, 34, 169, 220, 162, 27, 182, 169, 158, 73, 12, 135, 0, 226, 27, 60, 109, 220, 153, 189, 235, 141, 5, 27, 46, 27, 54, 103, 48, 14, 246, 34, 98, 99, 49, 132, 27, 49, 198, 176, 188, 74, 153, 93, 119, 27, 232, 106, 69, 222, 167, 206, 154, 64, 27, 201, 183, 0, 55, 73, 112, 113, 186, 27, 40, 30, 26, 178, 40, 242, 104, 15];
const C_SER: &[u8]= &[162, 100, 110, 97, 109, 101, 97, 67, 100, 110, 111, 100, 101, 161, 102, 80, 117, 98, 108, 105, 99, 162, 98, 99, 48, 163, 98, 99, 48, 162, 98, 99, 48, 132, 27, 139, 99, 162, 69, 75, 238, 217, 88, 27, 38, 8, 246, 124, 61, 239, 100, 211, 27, 75, 14, 204, 225, 232, 64, 106, 221, 27, 10, 127, 169, 34, 200, 201, 7, 163, 98, 99, 49, 132, 27, 82, 85, 90, 115, 14, 38, 24, 42, 27, 216, 221, 79, 42, 155, 7, 37, 120, 27, 157, 112, 119, 41, 189, 86, 10, 53, 27, 23, 18, 206, 34, 18, 1, 28, 236, 98, 99, 49, 162, 98, 99, 48, 132, 27, 23, 149, 14, 113, 91, 86, 39, 59, 27, 180, 50, 38, 98, 233, 51, 20, 151, 27, 238, 176, 210, 229, 148, 209, 116, 139, 27, 38, 74, 163, 116, 102, 35, 121, 142, 98, 99, 49, 132, 27, 183, 162, 94, 132, 39, 195, 103, 21, 27, 213, 100, 117, 107, 246, 165, 195, 188, 27, 149, 13, 124, 122, 247, 208, 119, 173, 27, 27, 224, 94, 155, 150, 141, 17, 157, 98, 99, 50, 162, 98, 99, 48, 132, 27, 82, 184, 229, 83, 62, 161, 176, 145, 27, 228, 6, 212, 136, 16, 70, 235, 77, 27, 166, 120, 136, 80, 85, 137, 22, 159, 27, 33, 99, 140, 227, 202, 155, 86, 63, 98, 99, 49, 132, 27, 9, 91, 28, 243, 65, 109, 33, 8, 27, 178, 164, 131, 246, 179, 48, 151, 40, 27, 247, 240, 49, 166, 38, 82, 54, 166, 27, 13, 120, 120, 135, 40, 229, 229, 161, 98, 99, 49, 163, 98, 99, 48, 162, 98, 99, 48, 132, 27, 248, 91, 100, 201, 198, 35, 76, 161, 27, 118, 253, 73, 238, 111, 43, 7, 11, 27, 132, 73, 132, 183, 21, 153, 192, 145, 27, 27, 85, 97, 87, 0, 145, 189, 54, 98, 99, 49, 132, 27, 111, 38, 228, 70, 57, 189, 195, 195, 27, 45, 79, 237, 232, 112, 95, 3, 166, 27, 48, 3, 179, 97, 9, 149, 217, 211, 27, 9, 45, 35, 171, 43, 151, 25, 118, 98, 99, 49, 162, 98, 99, 48, 132, 27, 231, 121, 166, 94, 28, 113, 179, 211, 27, 151, 32, 95, 138, 114, 122, 62, 59, 27, 186, 213, 9, 211, 19, 76, 241, 9, 27, 46, 59, 234, 185, 70, 242, 71, 135, 98, 99, 49, 132, 27, 27, 118, 254, 73, 75, 68, 211, 243, 27, 39, 200, 210, 89, 107, 116, 122, 187, 27, 110, 39, 70, 124, 16, 3, 115, 81, 27, 30, 87, 92, 198, 98, 211, 124, 217, 98, 99, 50, 162, 98, 99, 48, 132, 27, 17, 92, 88, 79, 92, 2, 86, 247, 27, 227, 29, 43, 218, 247, 58, 148, 39, 27, 234, 198, 25, 28, 231, 229, 168, 121, 27, 13, 12, 14, 177, 179, 253, 218, 141, 98, 99, 49, 132, 27, 212, 121, 243, 205, 247, 114, 121, 35, 27, 0, 128, 117, 7, 228, 228, 153, 240, 27, 200, 40, 210, 134, 14, 26, 135, 126, 27, 4, 152, 74, 99, 106, 222, 6, 100];

type S = consts::U8;

/// Initializes the YCT14 ABE system and loads a Yct14AbePublicKey from a serialized representation.
/// 
/// Call this function to get an instance of Yct14AbePublicKey, which needs to be passed to all other functions in this module.
/// Note that this does not set up a new ABE system and that the user can not choose the attribute universe at this point. This has to be done by the KGC. 
/// The nrf584xx is not supposed to know the secret keys corresponding to the attributes.
/// Currently, fixed public parameters are compiled into the library. There are three attributes named "A", "B" and "C" which may be used to encrypt data.
/// The goal is to allow the user to pass a byte array containing CBOR-serialized public parameters. This is not implemented yet
/// 
/// @param place_atts_here pointer to a memory location with enough space to store the three Attributes with their public keys. Each Yct14Attribute has byte-size 408
/// @param place_pubkey_here pointer to a memory location with enough space to store the Yct14AbePubkey. It is 400 Bytes long and in addition references the memory at `place_atts_here`.
///     Pass this memory location to all of the other functions.
/// @return Zero if everything went okay. Non-zero if an error occurred.
#[no_mangle]
pub extern "C" fn rabe_yct14_init<'attname, 'attlist>(place_atts_here: *mut [Yct14Attribute<'attname>; 3], place_pubkey_here: *mut Yct14AbePublicKey<'attname, 'attlist>) -> i32 {

    let mut scratch = [0; A_SER.len() * 2]; // just to be safe, double the size

    let g = match serde_cbor::de::from_slice_with_scratch(G_SER, &mut scratch) { Ok(g) => g, Err(_) => return 1};
    let a: Yct14Attribute = match serde_cbor::de::from_slice_with_scratch(A_SER, &mut scratch) { Ok(g) => g, Err(_) => return 1};
    let b: Yct14Attribute = match serde_cbor::de::from_slice_with_scratch(B_SER, &mut scratch) { Ok(g) => g, Err(_) => return 1};
    let c: Yct14Attribute = match serde_cbor::de::from_slice_with_scratch(C_SER, &mut scratch) { Ok(g) => g, Err(_) => return 1};

    unsafe { *place_atts_here = [a, b, c] };
    let atts: &[Yct14Attribute<'attname>] = unsafe { slice::from_raw_parts(&mut (*place_atts_here)[0] as *mut _, 3) };
    let pubkey = Yct14AbePublicKey::from_curve_elements(g, atts);
    unsafe { *place_pubkey_here = pubkey; };

    0
}

/// Encrypts a plaintext under a set of attributes and serializes the ciphertext with CBOR.
/// 
/// Does a full run of the YCT14 ABE scheme and encrypts a given plaintext under a given set of attributes such that they can only be reconstructed by
/// a key with a policy that is satisfied by the attributes given to this function.
/// 
/// Note that the data in the plaintext buffer is modified (i.e. encrypted) as encryption is internally performed in-place and only later serialized.
/// The ciphertext buffer must be large enough to handle the entire serialization of the ciphertext (> 2048 bytes).
/// 
/// @param params Pointer to the Yct14AbePublicKey obtained from `rabe_yct14_init`
/// @param plain_{buf, len} memory location and length of the plaintext buffer. The data in this buffer is modified
/// @param ct_{buf, len} memory location and length where the serialized ciphertext shall be written. The data in this buffer is also modified.
/// @param atts_{buf, len} memory location and length of the string containing the attributes. These should be contained in a single char[] separated by spaces.
///     For example the string "A B" would represent the attribute set {A, B}. The string does not need to be null-terminated, instead the length is passed explicitly.
/// @return The length of the serialized data in the ct_buf buffer. Zero if an error occured.
#[no_mangle]
pub extern "C" fn rabe_yct14_encrypt_and_serialize<'a, 'b>(
    params: *const Yct14AbePublicKey<'a, 'b>,
    plain_buf: *mut u8,
    plain_len: usize,
    ct_buf: *mut u8,
    ct_len: usize,
    atts_buf: *mut u8, // watch out, rust chars are 4 byte!! Separated by spaces.
    atts_len: usize,
) -> usize {
    let p = match hal::pac::Peripherals::take() {
        Some(p) => p,
        None => return 0,
    };
    let mut rng = hal::Rng::new(p.RNG);

    // preparation: do all the unsafe stuff
    let params = unsafe { &*params };
    let plain_buf = unsafe { slice::from_raw_parts_mut (plain_buf, plain_len) };
    let cipher_buf = unsafe { slice::from_raw_parts_mut(ct_buf, ct_len) };
    let atts_u8: &mut [u8] = unsafe { slice::from_raw_parts_mut(atts_buf, atts_len) };
    let atts: &mut str = unsafe { core::str::from_utf8_unchecked_mut(atts_u8) };
    let atts_array: Vec<&str, S> = atts.split(' ').collect();

    // encrypt - this changes the plaintext in-place
    let ct = match encrypt(&params, &atts_array, plain_buf, &mut rng) {
        Ok(ct) => ct,
        Err(_) => return 0,
    };

    // serialize the encrypted ciphertext into the ciphertext buffer
    let writer = SliceWrite::new(cipher_buf);
    let mut serializer = Serializer::new(writer);

    match ct.serialize(&mut serializer) {
        Ok(_) => (),
        Err(_) => return 0,
    };

    let writer = serializer.into_inner();

    let size = writer.bytes_written();
    size
}


/// Creates an ABE-encrypted curve element that can be used for multiple encryptions
/// 
/// This is the first step of a two-step encryption: It chooses a random curve point and encrypts it under the given attributes
/// with the YCT14 ABE scheme. This can then be used to encrypt one or multiple plaintexts such that they can be reconstructed using a key
/// that is satisfied by the given attributes set.
/// @param params Yct14AbePublicKey obtained by `rabe_yct14_init()`
/// @param atts_{buf, len} attribute set for encryption as with `rabe_yct14_encrypt_and_serialize()`
/// @param put_key_encapsulation_here memory location large enough to store the precomputed AES key and the curve elements necessary to reconstruct it under ABE
#[no_mangle]
pub extern "C" fn rabe_yct14_partial_encrypt_init<'a, 'b>(
    params: *const Yct14AbePublicKey<'a, 'b>,
    atts_buf: *mut u8, // watch out, rust chars are 4 byte!! Separated by spaces.
    atts_len: usize,
    put_key_encapsulation_here: *mut Yct14AbeKeyEncapsulation<'a>
) -> i32 {
    let p = match hal::pac::Peripherals::take() {
        Some(p) => p,
        None => return 0,
    };
    let mut rng = hal::Rng::new(p.RNG);

    let params = unsafe { &*params };
    let atts_u8: &mut [u8] = unsafe { slice::from_raw_parts_mut(atts_buf, atts_len) };
    let atts: &mut str = unsafe { core::str::from_utf8_unchecked_mut(atts_u8) };

    let atts_array: Vec<&str, S> = atts.split(' ').collect();

    let kem = match create_symmetric_key(params, &atts_array, &mut rng) {
        Ok(kem) => kem,
        Err(_) => return 1,
    };
    unsafe { *put_key_encapsulation_here = kem; };
    0
}


/// Encrypts a plaintext under a pre-computed curve element
/// 
/// This is the second step to `rabe_yct14_partial_encrypt_init`. It takes pre-computed AES key generated by the ABE scheme and encrypts a plaintext. It then
/// serializes this plaintext into CBOR. Calling this function yields a plaintext identical to what is generated by `rabe_yct14_encrypt_and_serialize`.
/// 
/// All parameters and return values are the same, except for 
/// @param encapsulated_aes_key the AES key and encapsulation information generated by `rabe_yct14_partial_encrypt_init()`
#[no_mangle]
pub extern "C" fn rabe_yct14_partial_encrypt_payload_and_serialize<'a>(
    encapsulated_aes_key: *const Yct14AbeKeyEncapsulation<'a>,
    plain_buf: *mut u8,
    plain_len: usize,
    ct_buf: *mut u8,
    ct_len: usize,
) -> usize {
    let p = match hal::pac::Peripherals::take() {
        Some(p) => p,
        None => return 0,
    };
    let mut rng = hal::Rng::new(p.RNG);

    // create safe slices from unsafe pointers
    let plain_buf = unsafe { slice::from_raw_parts_mut (plain_buf, plain_len) };
    let cipher_buf = unsafe { slice::from_raw_parts_mut(ct_buf, ct_len) };
    let key = unsafe { &*encapsulated_aes_key };

    // encrypt - this changes the plaintext in-place
    let ct = match encrypt_using_symmetric_key(key, plain_buf, &mut rng) {
        Ok(ct) => ct,
        Err(_) => return 0,
    };

    // serialize the encrypted ciphertext into the ciphertext buffer
    let writer = SliceWrite::new(cipher_buf);
    let mut serializer = Serializer::new(writer);

    match ct.serialize(&mut serializer) {
        Ok(_) => (),
        Err(_) => return 0,
    };

    let writer = serializer.into_inner();

    let size = writer.bytes_written();
    size
}

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}


#[cfg(test)]
mod test {
    use super::*;
    use std::prelude::v1::*;

    use std::println;

    use rabe_bn;
    #[test]
    fn print_sizeof() {
        println!("sizeof(Yct14AbeKeyEncapsulation) = {}", core::mem::size_of::<Yct14AbeKeyEncapsulation>());
        println!("sizeof(Yct14AbePublicKey) = {}", core::mem::size_of::<Yct14AbePublicKey>());
        println!("sizeof(Yct14AbeAttribute) = {}", core::mem::size_of::<Yct14Attribute>());
        println!("sizeof(Yct14AbeCiphertext) = {}", core::mem::size_of::<Yct14AbeCiphertext>());
        println!("sizeof(Gt) = {}", core::mem::size_of::<rabe_bn::Gt>());
    }
}